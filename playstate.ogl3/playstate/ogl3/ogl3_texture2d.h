#pragma once

#include <playstate/rendering/texture2d.h>
#include <gl/glew.h>

namespace playstate
{
	static const GLenum OGL3MinFilter[MinFilter::NUM_MIN_FILTERS] = {
		GL_NEAREST,
		GL_LINEAR,
		GL_NEAREST_MIPMAP_NEAREST,
		GL_LINEAR_MIPMAP_NEAREST,
		GL_NEAREST_MIPMAP_LINEAR,
		GL_LINEAR_MIPMAP_LINEAR
	};

	static const GLenum OGL3MagFilter[MagFilter::NUM_MAG_FILTERS] = {
		GL_NEAREST,
		GL_LINEAR
	};
	
	static const GLenum OGL3TextureWrap[TextureWrap::NUM_TEXTURE_WRAPS] = {
		GL_CLAMP_TO_EDGE,
		GL_CLAMP_TO_BORDER,
		GL_MIRRORED_REPEAT,
		GL_REPEAT
	};

	class OGL3Texture2D : public ITexture2D
	{
	public:
		OGL3Texture2D(GLuint textureID, const Size& size, TextureFormat::Enum format);
		virtual ~OGL3Texture2D();

		//
		// @return This textures width in pixels
		virtual const Size& GetSize() const;

		//
		// Binds this texture to the supplied active texture block
		//
		// @param activeTexture
		void Bind(uint32 activeTexture);

		//
		// Update this textures filters
		//
		//
		void UpdateFilters(MinFilter::Enum minFilter, MagFilter::Enum magFilter, TextureWrap::Enum ws, TextureWrap::Enum wt);
		
		//
		// @return A unique identifier with for this texture. This is needed because the
		//	ID object ID's generated by OpenGL are reused between deletes. The same thing is done by the
		//	operating system as well (regarding memory allocations and deletions).
		inline uint32 GetUUID() const {
			return mUUID;
		}

		inline GLuint GetID() const {
			return mTextureID;
		}

	// ITexture
	public:
		virtual TextureFormat::Enum GetFormat() const;

	protected:
		GLuint mTextureID;
		uint32 mUUID;
		TextureFormat::Enum mFormat;

		Size mSize;
		
		MinFilter::Enum mMinFilter;
		MagFilter::Enum mMagFilter;
		TextureWrap::Enum mWS;
		TextureWrap::Enum mWT;
	};
}
